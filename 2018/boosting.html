<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="集合算法," />





  <link rel="alternate" href="/atom.xml" title="Student" type="application/atom+xml" />






<meta name="description" content="本文是综合了之前的以往多个笔记汇总而成，内容包含： 一、Boosting基本概念 二、前向分步加法模型     1. 加法模型     2. 前向分步算法 三、AdaBoost     1. 算法解析     2. 模型构建     3. 算法缺点 四、二叉分类树 五、回归分类树     1. 算法解析     2. 模型构建 六、梯度提升树（GBDT）     1. 算法解析     2. 模">
<meta name="keywords" content="集合算法">
<meta property="og:type" content="article">
<meta property="og:title" content="提升树（Boosting tree）算法总结">
<meta property="og:url" content="http://www.ihoge.cn/2018/boosting.html">
<meta property="og:site_name" content="Student">
<meta property="og:description" content="本文是综合了之前的以往多个笔记汇总而成，内容包含： 一、Boosting基本概念 二、前向分步加法模型     1. 加法模型     2. 前向分步算法 三、AdaBoost     1. 算法解析     2. 模型构建     3. 算法缺点 四、二叉分类树 五、回归分类树     1. 算法解析     2. 模型构建 六、梯度提升树（GBDT）     1. 算法解析     2. 模">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15266077461675.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15266159564936.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15266164023757.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15266248077288.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15267353730899.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15267354146996.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15267877818108.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15268011299685.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15268013497837.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15268027278380.jpg">
<meta property="og:image" content="http://p6rvh6ej2.bkt.clouddn.com/15267180767470.jpg">
<meta property="og:updated_time" content="2018-05-28T07:52:54.331Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="提升树（Boosting tree）算法总结">
<meta name="twitter:description" content="本文是综合了之前的以往多个笔记汇总而成，内容包含： 一、Boosting基本概念 二、前向分步加法模型     1. 加法模型     2. 前向分步算法 三、AdaBoost     1. 算法解析     2. 模型构建     3. 算法缺点 四、二叉分类树 五、回归分类树     1. 算法解析     2. 模型构建 六、梯度提升树（GBDT）     1. 算法解析     2. 模">
<meta name="twitter:image" content="http://p6rvh6ej2.bkt.clouddn.com/15266077461675.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.ihoge.cn/2018/boosting.html"/>





  <title>提升树（Boosting tree）算法总结 | Student</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/hooog" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Student</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is short</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ihoge.cn/2018/boosting.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘知行">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Student">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">提升树（Boosting tree）算法总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T12:20:21+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>K
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<p>本文是综合了之前的以往多个笔记汇总而成，内容包含：</p>
<pre><code>一、Boosting基本概念
二、前向分步加法模型
    1. 加法模型
    2. 前向分步算法
三、AdaBoost
    1. 算法解析
    2. 模型构建
    3. 算法缺点
四、二叉分类树
五、回归分类树
    1. 算法解析
    2. 模型构建
六、梯度提升树（GBDT）
    1. 算法解析
    2. 模型构建
七、XGBoost
    1. 原理详解
    2. 目标函数
    3. 学习过程
    4. 损失函数
    5. 正则化
    6. 决策树的构建
    7. 流程步骤
    8. 优缺点
八、总结
    1. Boosting家族
    2. AdaBoost
    3. 回归提升树和AdaBoost
    4. GBDT和回归提升树   
    5. XGBoost和GBDT
    6. 参考文献
</code></pre><p>提升(Boosting)是集成学习方法里的一个重要方法，其主要思想是将弱分类器组装成一个强分类器。在 PAC（概率近似正确）学习框架下，则一定可以将弱分类器组装成一个强分类器。</p>
<p>提升树模型实际采用加法模型（即基函数的线性组合）与前向分步算法，以决策树为基函数的提升方法称为提升树（Boosting Tree）。</p>
<p><strong>对分类问题决策树是二叉分类树</strong>，<strong>对回归问题决策树是二叉回归树</strong>。</p>
<p>提升树模型可以表示为决策树的加法模型：<br>$$f_M(x)=∑^M_{i=1}T(x;\Theta _m)$$其中$T(x;\Theta _m)$表示决策树；$\Theta_m$表示决策树的参数；$M$为树的个数。</p>
<p>不同问题的提升树学习算法，其主要区别在于损失函数不同。<strong>平方损失函数常用于回归问题，用指数损失函数用于分类问题，以及绝对损失函数用于决策问题</strong>。</p>
<blockquote>
<p>由于树的线性组合可以很好的拟合训练数据，即使数据中的输入和输出之间的关系很复杂也是如此，所以提升树是一个高功能的学习算法。</p>
</blockquote>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>提升（Boosting）方法是一类应用广泛且非常有效的统计学习方法。</p>
<p><strong>它基于这样一种思想</strong>：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断好。实际上，就是“三个臭皮匠顶个诸葛亮”的道理。</p>
<p><strong>强可学习</strong>：如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的</p>
<p><strong>弱可学习</strong>：如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的</p>
<p><strong>AdaBoost算法</strong>：那么如何将弱学习算法提升为强学习算法呢？关于提升方法的研究很多，有很多算法被提出。最具代表性的是AdaBoost算法（AdaBoost algorithm）</p>
<p><strong>Boosting算法的两个核心问题</strong></p>
<ol>
<li><p><em>在每一轮如何改变训练数据的权值或概率分布</em></p>
<p> <code>通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</code>。</p>
</li>
<li><p><em>如何将弱分类器组合成一个强分类器</em></p>
<p> <code>通过加法模型将弱分类器进行线性组合，比如 AdaBoost 通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。</code>。</p>
</li>
</ol>
<blockquote>
<p>AdaBoost的巧妙之处就在于它将这些想法自然且有效地实现在一种算法里。<br>AdaBoost算法是损失函数为指数函数时的Boosting算法</p>
</blockquote>
<h2 id="二、前向分步加法模型（Forward-Stagewise-Additive-Modeling）"><a href="#二、前向分步加法模型（Forward-Stagewise-Additive-Modeling）" class="headerlink" title="二、前向分步加法模型（Forward Stagewise Additive Modeling）"></a>二、前向分步加法模型（Forward Stagewise Additive Modeling）</h2><h3 id="1-加法模型"><a href="#1-加法模型" class="headerlink" title="1. 加法模型"></a>1. 加法模型</h3><p>（形为$Y=I+U+T+K$的模型为加法模型）<br>$$f(x)=∑^M_{m=1}\beta _mb(x;\gamma  _m)$$ 其中，$b(x;\gamma_m)$为基函数，$\beta_m$为基函数的系数。</p>
<h3 id="2-前向分步算法"><a href="#2-前向分步算法" class="headerlink" title="2. 前向分步算法"></a>2. 前向分步算法</h3><p>在给定训练数据及损失函数$L(y,f(x))$的条件下，学习加法模型$f(x)$称为经验风险极小化，即损失函数极小化的问题：<br>$$min_{(\beta_m,\gamma_m)}∑^N_{i=1}L(y_i,∑^M_{m=1}\beta _mb(x_i;\gamma_m )) $$</p>
<p>通常这是一个复杂的优化问题。前向分布算法（forward stagwise algorithm）求解这一优化问题的思路是：因为学习的是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近优化目标函数式$f(x)=∑^M_{m=1}\beta _mb(x;\gamma  _m)$，那么就可以简化优化的复杂度。</p>
<p>具体地，每步只需优化如下损失函数:$$min_{\beta, \gamma}∑^M_{i=1}L(y_i,\beta b(x_i;\gamma))$$</p>
<p><strong>前向分布算法步骤</strong>如下：</p>
<blockquote>
<p><strong>输入</strong>：训练数据集$D={(x_1,y_1),(x_2,y_2),(x_3,y_3),…,(x_N,y_N)}$;损失函数$L(y,f(x))$；基函数集$(\beta (x;\gamma))$;<br><strong>输出</strong>：加法模型$f(x)$  </p>
<p>（1）初始化$f_0(x)=0$  </p>
<p>（2）对于$k=1,2,…,K$<br>（a）极小化损失函数，得到$\beta_m ,\gamma_m$:<br>    $$(\beta _m,\gamma_m)=argmin_{(\beta,\gamma)}∑^N_{i=1}L(y_i,f_{m-1}(x_i)+\beta b(x_i,\gamma))$$<br>（b）更新<br>    $$f_m(x)=f_{m-1}(x)+\beta _mb(x;\gamma_m)$$    </p>
<p>（3）得到加法模型<br>$$f(x)=f_M(x)=∑^M_{m=1}\beta_mb(x;\gamma_m)$$<br>这样。前向分步算法将同时求解从$m=1$到$m=M$所有参数$\beta_m,\gamma_m$的优化问题简化为逐次求解$\beta_m,\gamma_m$的优化问题。<br>前向分布算法学习的是加法模型，当基函数为基本分类器是，该加法模型等价于Adaboost的最终分类器。（AdaBoost算法参数迭代公式就是由此而来）</p>
<p><strong>基学习器</strong>：基函数为同一类型；反之称为<strong>组件学习器</strong>或直接成个体学习器</p>
</blockquote>
<h2 id="三、AdaBoost"><a href="#三、AdaBoost" class="headerlink" title="三、AdaBoost"></a>三、AdaBoost</h2><p>AdaBoost算法是前向分步算法的特例，其模型是由基本分类器组成的加法模型，损失函数是指数函数。</p>
<h3 id="1-AdaBoost算法解析"><a href="#1-AdaBoost算法解析" class="headerlink" title="1. AdaBoost算法解析"></a>1. AdaBoost算法解析</h3><p> <strong>AdaBoost模型是弱分类器的线性组合：</strong><br>    $$f(x)=∑^M_{m=1}\alpha _mG_m(x)$$</p>
<ul>
<li>$M$表示该提升树共有$M$个弱分类器组成</li>
<li>$G_m(x)$表示第$m$个弱分类器</li>
<li>$\alpha_m$为第$m$个弱分类器的参数（反应该分类器的重要性）</li>
</ul>
<p>Adaboost算法在分类问题中的主要特点：通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，提高分类性能。 AdaBoost－算法描述（伪代码）如下：</p>
<blockquote>
<p><strong>输入</strong>：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中$x_i\in \chi ⊆R^n,y_i\in Y={-1,1}$，弱学习算法$G_m(x)$;<br><strong>输出：</strong>最终强化算法分类器$G(x)$<br>（1）初始化训练数据总和为1的权值分布：（初始权重为归一化后的均值既$\frac 1N$）<br>$$D_1=(w_{11},…,w_{1i},…w_{1N}),w_{1i}=\frac 1N, i=1,2,…N$$<br>（2）对$m=1,2,…M$：（弱分类器的个数）<br>（a）使用具有权值分布的$D_m$的训练数据集学习，得到基本分类器：(数据集$X$到{-1,1}的映射)<br>$$G_m(x):X-&gt;{-1,1}$$<br>（b）计算$Gm(x)$在训练数据集上的分类误差率：（公式不够简洁明了，其实总结下来非常好理解：误差率$e_m$=误分类样本的权值之和）<br>$$e_m=∑^N_{i=1}P(G_m(x_i)≠y_i)=∑^N_{i=1}w_{mi}I(G_m(x_i)≠y_i)$$<br>我们来考虑下误差$e_m$的取值空间：由于训练集权制之和为1，因此误差$0≤e_m≤1$。但是这样还不够。因为我们在选择分裂阈值的时候会选择一个最优或局部最优的取值来分裂，且当$e_m=0.5$是表明该分裂阈值对预测无贡献。因此最终得到的$e_m$的实际取值应小于$e_m≤0.5$。<br>所以最终：$0≤e_m≤0.5$，且每次迭代误差$e_m$递减。这点对下面的参数理解很重要。<br>（c）计算$G_m(x)$的系数:(这里对数为自然对数)<br>$$\alpha_m=\frac 12log\frac{1-e_m}{e_m} $$<br>那么问题来了，为什么要用这个公式来计算更新每个基分类器的参数？我们先画个图出来观察下这个函数。（其中y轴为$\alpha _m$，x轴为误差$e_m$）</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15266077461675.jpg" alt=""></p>
<p>由（2-b）我们得到误差$e_m$的取值范围为$0≤e_m&lt;0.5$，结合该图可以可知$0&lt;\alpha_m&lt;+\infty $。<br>另外可以发现，通过该函数的转换，弱分类器$G_m(x)$的误差的越小，参数$\alpha_m$越大。即实现了<strong><code>给分类误差率小的基本分类器以大的权值，给分类误差率大的基本分类器以小的权值</code></strong><br>（d）更新训练数据集的权值分布：（该权值决定数据集的重要性，并让误差的计算变得简单）<br>$$D_{m+1}=(w_{m+1,1},…,w_{m+1,i},…w_{m+1,N})$$<br>$$w_{m+1,i}=\frac {w_{mi}}{Z_m}exp(-\alpha_my_iG_m(x-i)),i=1,2,…N$$<br>这里$y_i={-1,1} $为真实值，$G_m(x_i)={-1,1}$为预测值。当预测正确时$y_iG_m(x_i)$为1，反之为-1。<br>令$\delta_{m_i}=\alpha_my_iG_m(x_i)$，$\theta_{mi}=\frac {w_{mi}}{Z_m}$(把它看作一个用于归一化权值的加权平均常数)。权重$w_{m+1,i}$的更新函数可以简化为$$w_{m+1,i}=\theta_{mi}exp(\delta <em>{mi}),i=1,2,…N$$画出$y=w</em>{m+1,i}=exp(\delta_{mi})$的图形来看一下：</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15266159564936.jpg" alt=""></p>
<p>由于$0&lt;\alpha_m&lt;1$，所以$-1&lt;\delta_{m,i }&lt;1$。且<strong>使得预测错误的数据集样本点更新后的权重变大，预测正确的权值变小，然后对所有权值进行归一化</strong>。这就是该函数实现的作用。(图中y=1是当$\alpha$无限接近于0时的情况：解释为，当$\alpha_m$权值越大，权重$w_{m+1,i}$更新改变的效果越明显。)<br>这里，$Z_m$是规范化因子，目的是使各数据集的权重进行归一化。理解为$Z_m$=更新后的各数据集权重之和。<br>$$Z_m=∑^N_{i=1}w_{mi}exp(-\alpha_my_iG_m(x_i))$$<br>（3）构建基本分类器的新型组合$f(x)=∑^M_{m=1}\alpha_mG_m(x)$，即：<br>$$G(x)=sign(f(x))=sign(∑^M_{m=1}\alpha_mG_m(x))$$<br>函数$sign()$的意义是将正数判别为1，负数判别为-1，最终达到分类的目的。如图：</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15266164023757.jpg" alt=""></p>
</blockquote>
<h3 id="2-AdaBoost构建步骤"><a href="#2-AdaBoost构建步骤" class="headerlink" title="2. AdaBoost构建步骤"></a>2. AdaBoost构建步骤</h3><blockquote>
<p>上面解释了AdaBoost算法的具体内容。这里写出它的分布实现步骤再对上文算法加深下理解：<br>（1）假设训练数据集具有均匀的权值分布，即每个训练样本在基本分类器的学习中作用相同，这一假设保证第1步能够在原始数据上学习基本分类器$G_1(x)$。<br>（2）AdaBoost反复学习基本分类器，在每一轮$m＝1,2,…,M$顺次地执行下列操作：<br>（a）使用当前分布$D_m$加权的训练数据集，学习基本分类器$G_m(x)$<br>（b）计算基本分类器$G_m(x)$再加权训练数据集上的分类误差率（即误分类样本的权值之和。这里要注意$w_{mi}$表示第$m$轮中第$i$个实例的权值，且权值之和为1，即$∑^N_{i=1}w_{mi}=1$）：<br>$$e_m=P(G_m(x_i)≠y_i)=∑_{G_m(x_i)≠y_i}w_{mi}$$<br>（c）计算基本分类器$G_m (x)$的系数$\alpha_m$。$alpha_m$表示$G_m(x)$在最终分类器中的重要性。由上面（2-c）可知，<strong>当$e_m≤1/2$时，$alpha_m≥0$，并且$\alpha_m$随着$e_m$的减小而增大，所以分类误差率越小的分类器在最终分类器中的作用越大。</strong><br>（d）更新训练数据的权值分布为下一轮作准备。式（2-d）的权重更新函数可以写成：</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15266248077288.jpg" alt="">    </p>
<p> 由此可知，被基本分类器$G_m (x)$误分类样本的权值得以扩大，而被正确分类样本的权值却得以缩小。两相比较，误分类样本的权值被放大$e^{(2\alpha_m)}=\frac{e_m}{1-e_m} $倍。因此，误分类样本在下一轮学习中起更大的作用。不改变所给的训练数据，而不断改变训练数据权值的分布，使得训练数据在基本分类器的学习中起不同的作用，这是AdaBoost的一个特点。<br>（3）线性组合$f(x)$实现$M$个基本分类器的加权表决。系数$\alpha_m$ 表示了基本分类器$G_m (x)$的重要性，这里，所有$\alpha_m$ 之和并不为1。$f(x)$的符号决定实例x的类，$f(x)$的绝对值表示分类的确信度。利用基本分类器的线性组合构建最终分类器是AdaBoost的另一特点。</p>
</blockquote>
<h3 id="3-AdaBoost算法缺点"><a href="#3-AdaBoost算法缺点" class="headerlink" title="3. AdaBoost算法缺点"></a>3. AdaBoost算法缺点</h3><p><strong>1. 常规AdaBoost算法只能处理二分类问题</strong></p>
<p>MultiBoost工具的侧重点不同于XGBoost，是Adaboost算法的多分类版本实现，更偏向于解决multi-class / multi-label / multi-task的分类问题。</p>
<p><strong>2. 对异常值敏感</strong></p>
<p>指数损失存在的一个问题是不断增加误分类样本的权重（指数上升）。如果数据样本是异常点（outlier），会极大的干扰后面基本分类器学习效果；</p>
<p><strong>3. 模型无法用于概率估计</strong></p>
<p>对于取值为$\hat y \in {-1,1}$的随机变量说，$e^{-\hat yf}$不是任何概率密度函数的对数形式，模型$f(x)$的结果无法用概率解释。<br>MLAPP中的原话：$e^{-\hat y f}$is not the logarithm of any pmf for binary variables $\hat y \in {-1,1}$; consequently we cannot recover probability estimate from $f(x)$.”</p>
<h2 id="四、二叉分类提升树（如AdaBoost）"><a href="#四、二叉分类提升树（如AdaBoost）" class="headerlink" title="四、二叉分类提升树（如AdaBoost）"></a>四、二叉分类提升树（如AdaBoost）</h2><p>对于二类分类问题，提升树算法只需要将AdaBoost算法例子中的基本分类器限制为二叉分类树即可，可以说<strong>此时的决策树算法时AdaBoost算法的特殊情况</strong>。</p>
<p><strong>二叉分类树中用基尼指数作为最优特征选择的度量标准。</strong></p>
<p>在实际操作中，通过遍历所有特征（如果是连续值，需做离散化）及其取值，选择基尼指数最小所对应的特征和特征值。</p>
<h2 id="五、二叉回归提升树"><a href="#五、二叉回归提升树" class="headerlink" title="五、二叉回归提升树"></a>五、二叉回归提升树</h2><p><strong>二叉回归树采用平方误差最小化作为特征选择和切分点选择的依据</strong>。</p>
<p>下面要解决的问题是：如何划分特征空间？</p>
<p>一个启发式的方式就是选择特征空间中第$m$个特征$f_m$和它的取值$s$,作为划分特征和划分点，然后寻找最优划分特征$f_m$和最优划分点$s$。</p>
<p><strong>具体操作就是遍历所有未划分过的特征集合和对应的取值（集合）</strong>求解得出另损失函数最小的参数$f_m和s$。</p>
<h3 id="1-回归问题提升树算法解析"><a href="#1-回归问题提升树算法解析" class="headerlink" title="1. 回归问题提升树算法解析"></a>1. 回归问题提升树算法解析</h3><p>对于二类分类问题，提升树算法只需将AdaBoost算法中的基本分类器限制为二类分类树即可，可以说这时的提升树算法是AdaBoost算法的特殊情况，这里不再细述。</p>
<p>已知一个训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)},x_1 \in \chi ⊆ R^n$，$ \chi $为输入空间，$y_i \in Y ⊆ R$，$Y$为输出空间。如果将输入空间$\chi $划分为$J$个互不相交的区域$R_1,R_2,…R_J$，并且在每个区域上确定输出的敞亮$c_j$，那么树可以表示为：$$T(x; \Theta)=∑^J_{j=1}c_jI(x \in R_j)$$</p>
<p>其中参数$\Theta ={(R_1,c_1),(R_3,c_2),…,(R_J,c_J)}$表示树的区域划分和各区域上的常数。$J$是回归树的复杂度即叶节点的个数。</p>
<blockquote>
<p>$f_0(x)=0$<br>$f_m(x)=f_{m-1}(x)+T(x;\Theta_m),m=1,2,…,M$<br>$f(x)=f_M(x)=∑^M_{m=1}T(x;\Theta_m)$</p>
<p>在前向分步算法的第$m$步，给定当前模型$f_{m-1}(x) $，需求解：</p>
<p>$Pred (\Theta_m)$<br>$=argmin_{(\Theta_m)}∑^N_{i=1}L(y_i,f_m(x_i))$<br>$=argmin_{(\Theta_m)}∑^N_{i=1}L(y_i,f_{m-1}(x_i)+T(x_i;\Theta_m ))$<br>得到$Pred(\Theta _m)$，即第$m$棵树的参数。</p>
<p>当采用平方误差损失函数$L(y,f(x))=(y-f(x))^2$时，其损失变为：</p>
<p>$L(y,f_{m-1}(x)+T(x;\Theta_m ) )$<br>$=[y-f_{m-1}(x)-T(x;\Theta_m )]^2$<br>$=[\gamma -T(x;\Theta_m)]^2$</p>
<p>这里$\gamma=y-f_{m-1}(x)$<strong>是当前模型拟合数据的残差（这点很重要）</strong>。所以，对回归问题的提升算法来说，只需要简单地拟合当前模型的残差。这样算法是很简单地。</p>
</blockquote>
<h3 id="2-回归提升树构建步骤"><a href="#2-回归提升树构建步骤" class="headerlink" title="2. 回归提升树构建步骤"></a>2. 回归提升树构建步骤</h3><blockquote>
<p><strong>输入</strong>：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)},x_1 \in \chi ⊆ R^n$，$y_i \in Y ⊆ R$；<br><strong>输出</strong>：回归提升树$f(x)$;<br>（1）初始化$f_0(x)=0 $</p>
<p>（2）对$m=1,2,…,M$</p>
<p>（a）计算或更新残差<br>$$\gamma _{mi}=y_i-f_{m-1}(x_i),i=1,2,…,N$$<br>（b）拟合残差$\gamma_{mi}$学习一个回归树，得到$T(x; \Theta_m)$<br>（c）更新$f_m(x)=f_{m-1}(x)+T(x;\Theta_m)$<br>（d）重复步骤（a～c）知道满足终止条件</p>
<p>（3）得到回归问题提升树<br>$$f(x)=f_M(x)=∑^M_{m=1}T(x;\Theta_m)$$</p>
</blockquote>
<h2 id="六、梯度提升树（GBDT）"><a href="#六、梯度提升树（GBDT）" class="headerlink" title="六、梯度提升树（GBDT）"></a>六、梯度提升树（GBDT）</h2><h3 id="1-梯度提升树-GBDT-算法解析"><a href="#1-梯度提升树-GBDT-算法解析" class="headerlink" title="1. 梯度提升树(GBDT)算法解析"></a>1. 梯度提升树(GBDT)算法解析</h3><p><strong>Gradient boosting</strong> 就是通过加入新的弱学习器，来努力纠正前面所有弱学习器的残差，最终这样多个学习器相加在一起用来进行最终预测，准确率就会比单独的一个要高。之所以称为 Gradient，是因为在添加新模型时使用了梯度下降算法来最小化的损失。<br><strong>利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中残差的近似值，拟合一个回归树。</strong></p>
<p>损失函数的负梯度为：<br><img src="http://p6rvh6ej2.bkt.clouddn.com/15267353730899.jpg" alt=""></p>
<p>也就是说梯度提升树（GBDT）本质上和提升回归树类似，唯一不同的是使用损失函数的负梯度在当前模型的值取近似替代回归提升树中的残差去拟合回归树。这里算法解析部分可以参考上文回归提升树。</p>
<h3 id="2-梯度回归树（GBDT）构建步骤"><a href="#2-梯度回归树（GBDT）构建步骤" class="headerlink" title="2. 梯度回归树（GBDT）构建步骤"></a>2. 梯度回归树（GBDT）构建步骤</h3><blockquote>
<p><strong>输入</strong>：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)},x_1 \in \chi ⊆ R^n$，$y_i \in Y ⊆ R$；<br><strong>输出</strong>：梯度提升树$\hat{f}(x) $;(因为这里用损失函数负梯度的值去近似残差，因此使用$\hat{f}(x) $更严谨些)<br>（1）初始化：这里初始化与回归提升树略有不同<br>$$f_0(x)=argmin_c∑^N_{i=1}L(y_i,c)$$</p>
<p>（2）对$m=1,2,…,M$<br>（a）对$i=1,2,…,M$计算损失函数在当前模型的值作为残差$\gamma_{mi}$的近似</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15267354146996.jpg" alt=""></p>
<p>（b）对$\gamma_{mi}$拟合一个回归树，得到第$m$棵树的叶节点区域$R_{mj}$，$j=1,2,…,J$<br>（c）对$j=1,2,..,J$，计算<br>$$c_{mj}=argmin_{(c)}∑_{(x_i \in R_{mj})}$$<br>（d）更新$f_m(x)=f_{m-1}+∑^J_{j=1}c_{mj}I(x\in R_{mj})$</p>
<p>（3）得到回归树<br>$$\hat{f}(x)=f_M(x)=∑^M_{m=1}∑^J_{j=1}c_{mj}I(c\in R_{mj})$$</p>
</blockquote>
<p><strong>算法解释</strong>：</p>
<ol>
<li>第（1）步初始化，估计使用损失函数极小化的常数值，它是只有一个根结点的树。</li>
<li>第（2a）步计算损失函数的负梯度在当前模型的值，将它作为残差的估计。对于平方损失函数，就是通常所说的残差；对于一般损失函数，它就是残差的近似值。</li>
<li>第（2b）步估计回归树叶节点区域，以拟合残差的近似值。</li>
<li>第（2c）步<strong>利用线性搜索估计叶节点区域的值，是损失函数极小化</strong>。</li>
<li>第（2d）步更新回归树，然后输出最终模型$\hat{y}(x)$。</li>
</ol>
<h3 id="3-GBDT缺点"><a href="#3-GBDT缺点" class="headerlink" title="3. GBDT缺点"></a>3. GBDT缺点</h3><p> <strong>效率低</strong>：gradient boosting 的实现是比较慢的，因为每次都要先构造出一个树并添加到整个模型序列中。所以就有了<strong>XGBoost</strong>。</p>
<h2 id="七、XGBoost"><a href="#七、XGBoost" class="headerlink" title="七、XGBoost"></a>七、XGBoost</h2><h3 id="1-XGBoost原理详解"><a href="#1-XGBoost原理详解" class="headerlink" title="1. XGBoost原理详解"></a>1. XGBoost原理详解</h3><p>前面介绍了提升树算法，其实 XGBoost 就是一种特殊的提升树算法，准确的说它是一种梯度提升决策树（GBDT ，Gradient Boosting Decision Trees）。GBDT 与前面介绍的提升树方法主要的区别就是利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中残差的近似值，来拟合一颗回归树，即：</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15267877818108.jpg" alt=""></p>
<p>XGBoost 就是对 GBDT 的实现，但是一般来说，gradient boosting 的实现是比较慢的，因为每次都要先构造出一个树并添加到整个模型序列中。</p>
<p>而 XGBoost 的特点就是<strong>计算速度快</strong>，<strong>模型表现好</strong>，这两点也正是这个项目的目标。</p>
<h3 id="2-XGBoost的目标函数"><a href="#2-XGBoost的目标函数" class="headerlink" title="2. XGBoost的目标函数"></a>2. XGBoost的目标函数</h3><p>传统 GBDT 算法的目标函数只有损失函数这一项，而 XGBoost 在此基础上进行了改进，增加了正则项以防止模型过度复杂：</p>
<p>$$Obj =∑^N_{i=1}L(y_i,\hat{y}<em>i)+∑</em>{m=1}^M\Omega(f_m), f_m \in F$$</p>
<p>在这里我们不能够使用 SGD 算法进行优化，因为我们需要寻找的新的函数 f 是一棵树，而不仅仅是一个数值向量。解决方案也是和提升树一样，采用 Boosting 的思想，<strong>从一个常量（通常是0）进行预测，每次添加一个新的预测残差的函数</strong>：<br>$f_0(x)=0$<br>$f_m(x)=f_{m-1}(x)+T(x;\Theta_m)$<br>$f_M(x)=∑^M_{m=1}T(x;\Theta_m),m=1,2,…,M$</p>
<p>由以上公式我们可以知道，我们所要做的唯一的一件事就是寻找一个方法来确定第$m$轮的函数$f_m(x_i)$。但是怎么确定每一轮迭代的函数$f_m(x)$呢，答案是优化！</p>
<h3 id="3-XGBoost算法学习过程"><a href="#3-XGBoost算法学习过程" class="headerlink" title="3. XGBoost算法学习过程"></a>3. XGBoost算法学习过程</h3><p>第$m$轮迭代的预测结果为：<br>$$\hat{y}_m(x_i)=\hat{y}_{m-1}(x_i)+f_m(x_i)$$</p>
<p>目标函数为：</p>
<p>$Obj_m =∑^N_{i=1}L(y_i,f_m(x_i))+∑_{m=1}^M\Omega(f_m)$</p>
<p>$=∑^N_{i=1}L(y_i,f_{m-1}(x)+f_m(x_i)+\Omega(f_m))+const$</p>
<p>推导到这里，应该就清楚了，我们的目标就是最小化上式去除常量的部分。那么我们首先来考虑一下损失函数为平方(Square）损失的情况，即：</p>
<p>$Obj_m =∑^N_{i=1}(y_i,f_{m-1}(x_i)+f_m(x_i))^2+\Omega(f_m)$</p>
<p>$=∑^N_{i=1}[2(f_{m-1}-y_i)f_m(x_i)+f_m(x_i)^2]+\Omega(f_m)+const$</p>
<p>有上述分析，我们知道对于目标函数当我们将损失函数设定为平方损失的时候，目标函数最终可转化为一个关于 $f_m(x)$ 的二次函数，这时候我们很容易对其进行优化，甚至可以求出它的解析解。</p>
<p>但是，为了算法的通用性和可扩展性的考虑，XGBoost 并没有指定损失函数为平方损失函数，此时我们会发现其实目标函数的表达是还是相当复杂的： </p>
<p>$$Obj_m=∑^N_{i=1}L(y_i,f_{m-1}(x_i)+f_m(x_i))+\Omega(f_m)+const$$</p>
<p>这时候该怎么做呢，陈天奇大神想出了我们高数中学过的泰勒展开式，具体怎么做的呢？</p>
<h3 id="4-泰勒展开时近似损失函数"><a href="#4-泰勒展开时近似损失函数" class="headerlink" title="4. 泰勒展开时近似损失函数"></a>4. 泰勒展开时近似损失函数</h3><p>为了更好的介绍 XGBoost 中是如何使用泰勒展开式来近似损失函数的，首先让我们回顾一下泰勒展开式的二阶形式：</p>
<p>$$f(x+\Delta x)=f(x)+f’(x)\Delta x+\frac 12f’’(x)\Delta x^2+R(\Delta x)$$</p>
<p>其中$R(\Delta x)$表示$\Delta x$的高阶无穷小。因此，有：<br>$$f(x+\Delta x)\approx f(x)+f’(x)\Delta x+\frac 12f’’(x)\Delta x^2$$</p>
<p>有了泰勒公式，我们给出如下定义：</p>
<p>$$g_i=\partial _{f_{m-1}(x_i)}L(y_i, f_{m-1}(x_i))$$<br>$$h_i=\partial^2 _{f_{m-1}(x_i)}L(y_i, f_{m-1}(x_i))$$</p>
<p>这里我们把$L(y_i,f_{m-1}(x_i))$看成是$f_{m-1}(x_i)$为自变量的函数，因此$g_i$和$h_i$为其一阶导和二阶导数（其实是偏导），并且我们将目标函数中的$f_m(x_i)$看成上式中自变量的增量$\Delta x$，因此将目标函数按$f_{m-1}(x_i)$进行泰勒展开，得到：</p>
<p>$Obj_m=∑^N_{i=1}L(y_i,f_{m-1}(x_i)+f_m(x_i))+ \Omega(f_m)+const$<br>$\approx ∑^N_{i=1}[L(y_i,f_{m-1}(x_i))+g_if_m(x_i)+\frac 12h_if^2_m(x_i)] + \Omega(f_m)+const$</p>
<p>去除掉常量部分，我们可以得到新的目标函数：<br>$$Obj_m=∑^N_{i=1}[g_if_m(x_i)+\frac 12 h_if^2_m(x_i)]+\Omega(f_m) $$</p>
<p>这样做的好处是：</p>
<blockquote>
<p><strong>理论上的好处</strong>：使得我们更加清楚的知道我们在学习什么，以及更好的收敛性；<br><strong>工程上的好处</strong> ：</p>
<ol>
<li>$g_i$和$h_i$都来自于损失函数的定义</li>
<li>函数的学习过程仅仅通过$g_i$和$h_i$依赖于目标函数</li>
<li>可以利用不同的模块分开实现不同的损失函数，例如平方损失函数和 logistic 损失函数，这样损失函数不会受限制。</li>
</ol>
</blockquote>
<h3 id="5-正则化的处理"><a href="#5-正则化的处理" class="headerlink" title="5. 正则化的处理"></a>5. 正则化的处理</h3><p>目标函数中正则化项存在的原因是为了限制模型的复杂度，<strong>让模型在训练集上能够取得较好的结果的前提下尽可能地简单</strong>。而前面我们也提到了，在 XGBoost 中，对于采用前向分布方法一步步迭代的优化时，我们模型的复杂度就是当前要定义的决策树的复杂度。</p>
<h4 id="决策树函数的定义"><a href="#决策树函数的定义" class="headerlink" title="决策树函数的定义"></a>决策树函数的定义</h4><p>为此，我们首先重新定义树：我们将树定义为一个该树中所有叶子节点的值的向量。并且，每个叶子的索引映射函数映射实例到每个叶子节点上：<br><img src="http://p6rvh6ej2.bkt.clouddn.com/15268011299685.jpg" alt=""></p>
<h4 id="定义决策树的复杂度"><a href="#定义决策树的复杂度" class="headerlink" title="定义决策树的复杂度"></a>定义决策树的复杂度</h4><p>我们将决策树的复杂度，也就是目标函数定义如下：<br>$$\Omega (f_m)=\gamma T+\frac 12\lambda∑^T_{j=1}w_j^2$$</p>
<p>其中，$T$树中叶子结点的个数计算如下：<br><img src="http://p6rvh6ej2.bkt.clouddn.com/15268013497837.jpg" alt=""></p>
<h4 id="新目标函数的优化"><a href="#新目标函数的优化" class="headerlink" title="新目标函数的优化"></a>新目标函数的优化</h4><p>首先，我们对叶子节点$j$中的实例进行如下定义：<br>$$I_j={i|q(x_i)=j }$$<br>此时目标函数为：<br>$$Obj_m\approx ∑^N_{i=1}[g_if_m(x_i)+\frac 12 h_if_m^2(x_i)]+\Omega(f_m)+const$$<br>$$=∑^N_{i=1}[g_iw_{q(x_i)}+\frac 12h_iw^2_{q(x_i)}]+\gamma T+\frac 12 \lambda ∑^T_{j=1}w^2_j$$<br>$$=∑^T_{j=1}[(∑_{i\in I_j}g_i)w_i+\frac 12(∑_{i \in I_j}h_i+\lambda)w^2_j]+\gamma T $$</p>
<p>首先，我们进行如下定义：</p>
<p>$$G_j=∑_{i \in I_j}g_i,H_j=∑_{i \in I_j}h_i$$</p>
<p>进一步简化目标函数：<br>$$Obj_m=∑^T_{j=1}[G_jw_j+\frac 12(H_i+\lambda)w^2_j]+\gamma T$$</p>
<p>众所周知，对于一元二次函数，由如下两条结论：<br>$$arg \min _xG_x + \frac 12Hx^2=-\frac GH,H&gt;0$$<br>$$\min _xG_x+\frac 12Hx^2=- \frac {G^2}{2H}$$</p>
<p>因此对于目标函数进行最小化，当$w_j=-\frac {G_j}{H_j+\lambda }$时，我们得到：<br>$$\min _{Obj_m}=∑^T_{j=1}[G_jw_j+\frac 12(H_j+\lambda)w^2_j]+\gamma T$$<br>$$=-\frac 12 ∑^T_{j=1}\frac {G^2_j}{H_j+\lambda }+\gamma T$$<br><img src="http://p6rvh6ej2.bkt.clouddn.com/15268027278380.jpg" alt=""></p>
<p>至此，对于第 t 轮的一颗已经分裂好的决策树，我们能够求出其对应的最小化的目标函数。但是到目前为止，到底如何进行分裂我们还不知道具体的做法，接下来让我们一起学习 XGBoost 是如何寻找分裂点的。</p>
<h3 id="6-决策树构建"><a href="#6-决策树构建" class="headerlink" title="6. 决策树构建"></a>6. 决策树构建</h3><h4 id="决策树的生成策略"><a href="#决策树的生成策略" class="headerlink" title="决策树的生成策略"></a>决策树的生成策略</h4><p>对于回归决策树来说，在目标函数已经确定的情况下，接下来我们的问题是如何寻找对于当前训练样本的最优的决策树结构。当然，我们最容易想到的是穷举法。如果按照穷举法，我们列出所有的可能的决策树的结构$q$，然后基于决策树结构$q$去计算它的目标函数值，在计算完所有可能的决策树结构后，选择目标函数值最小的决策树结构$\hat q$作为最终决策树。</p>
<p>虽然理论上来说，穷举法能够寻找到最优的决策树结构，但是在有限的时间内我们无法去寻找到最优的决策树结构，因为可能的树结构有无穷多种。因此，在应用中我们采用的是贪心的策略来一步步地增长树的结构。也就是从根节点开始，不断地进行递归地分裂，直至在给定的准则下无法进行分裂为止。所以，接下来我们需要知道递归时如何进行合适并有效地分裂当前节点。</p>
<h4 id="寻找最优分裂点"><a href="#寻找最优分裂点" class="headerlink" title="寻找最优分裂点"></a>寻找最优分裂点</h4><p>对于一个叶子节点，如何进行分裂我们需要遵循的原则是分裂后的两颗子树的最优目标函数值之和要小于未分裂之前的父节点，为了叙述方便我们定义如下的目标函数值的 “增益”：\<br>$$Gain=\frac 12[\frac {G^2_L}{H_L+\lambda } + \frac {G^2_R}{H_R+\lambda } - \frac {(G_L+G_R)^2}{H_L+H_R+\lambda } -\gamma ]$$<br>上式表示的是在某个节点分裂前的目标函数值与分裂后的目标函数值的差值，由于我们的目标是寻找到最优的决策树，也就是说只有当$Gain$的值为正时我们才会选择进行分裂。</p>
<blockquote>
<p><strong>分裂点寻找方法</strong>：</p>
</blockquote>
<blockquote>
<ul>
<li>对每一个待分裂节点，枚举出所有的特征；</li>
<li>对于每一个特征，根据该特征将所有的实例进行排序；</li>
<li>使用线性扫描的方法计算该特征的每个可能的值作为分裂点时对应的 $Gain$对所有特征，使用上述扫描过程中找到的 $Gain$ 值大时特征及其对应的取值作为分裂点，将当前节点一分为二。</li>
</ul>
</blockquote>
<h4 id="离散变量处理"><a href="#离散变量处理" class="headerlink" title="离散变量处理"></a>离散变量处理</h4><p>传统的 GBDT 算法对连续型变量和离散型变量是进行分开处理的。例如 Spark 中的 GBDT 就是这样的，当我们的实例特征中有离散型变量的时候，就需要通过参数指定该离散型变量的种类，这样使得算法的用户友好性变得十分的糟糕。</p>
<p>而 XGBoost 在设计时就考虑到了这一点。实际上，我们不需要将离散型特征变量进行分开处理，XGBoost 使用 one-hot 编码的方式对离散型变量进行处理。</p>
<h4 id="剪枝策略"><a href="#剪枝策略" class="headerlink" title="剪枝策略"></a>剪枝策略</h4><ul>
<li><strong>前剪枝</strong><ul>
<li>当最优分裂点对应的增益值为负时停止分裂</li>
<li>但是这也会存在问题，即将来的某个时刻能够获取更高的增益</li>
</ul>
</li>
<li><strong>后剪枝</strong><ul>
<li>将决策树增长到它的最大深度，递归的进行剪枝，剪去那些使得增益值为负值的叶子节点。</li>
</ul>
</li>
</ul>
<h4 id="前向分步的步长"><a href="#前向分步的步长" class="headerlink" title="前向分步的步长"></a>前向分步的步长</h4><p>在 XGBoost 提升过程中，每产生一颗对当前残差最优化的决策树 $f_m(x)$时，并不是直接将决策树$f_m(x)$加入到模型中，而是对它乘以一个固定的算法参数 $\eta$之后才加入到模型中：</p>
<p>$$f_m(x)=f_{m-1}(x)+\eta f_m(x)$$</p>
<p>这样做的好处是防止单步决策树过拟合，以减少每棵树对最终木星的影响。</p>
<h3 id="7-XGBoost构建步骤流程"><a href="#7-XGBoost构建步骤流程" class="headerlink" title="7. XGBoost构建步骤流程"></a>7. XGBoost构建步骤流程</h3><blockquote>
<p><strong>输入</strong>：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)},x_1 \in \chi ⊆ R^n$，$y_i \in Y ⊆ R$；<br><strong>输出</strong>：梯度提升树$\hat{f}(x) = \hat f_M(x)$;</p>
<p>（1）初始化$f_0(x)=0$</p>
<p>（2）对$m=1,2,…,M$，依次进行循环迭代：</p>
<p>（a）对每个样本点，分别计算：<br>$$g_i= \partial _{f_{m-1}(x_i)}L(y_i,f_{m-1}(x_i))$$<br>$$h_i= \partial ^2_{f_{m-1}(x_i)}L(y_i,f_{m-1}(x_i))$$<br>（b）使用贪心策略构建一棵树$f_m(x)$，以使得下列的目标函数最小化：<br>$$Obj=-\frac 12 ∑^T_{j=1}\frac {G_j^2}{H_j+\lambda }+\gamma T$$<br>（c）更新：$f_M(x)=f_{m-1}(x)+\eta f_m(x)$<br>（3）得到XGBoost提升树：<br>$$f(x)=f_M(x)=∑^M_{m=1}\eta f_m(x)$$</p>
</blockquote>
<h3 id="8-XGBoost优缺点"><a href="#8-XGBoost优缺点" class="headerlink" title="8. XGBoost优缺点"></a>8. XGBoost优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>正则化</strong></li>
</ol>
<p>XGBoost 在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的 score 的 L2 模的平方和。从 Bias-variancetradeoff 角度来讲，正则项降低了模型的 variance，使学习出来的模型更加简单，防止过拟合，这也是 XGBoost 优于传统 GBDT 的一个特性。</p>
<ol start="2">
<li><strong>并行处理</strong></li>
</ol>
<p>XGBoost 工具支持并行。Boosting 不是一种串行的结构吗?怎么并行的？注意 XGBoost 的并行不是 tree 粒度的并行，XGBoost 也是一次迭代完才能进行下一次迭代的（第 t 次迭代的代价函数里包含了前面 t-1 次迭代的预测值）。XGBoost 的并行是在特征粒度上的。</p>
<p>我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），XGBoost 在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个 block 结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p>
<ol start="3">
<li><strong>灵活性</strong></li>
</ol>
<p>XGBoost 支持用户自定义目标函数和评估函数，只要目标函数二阶可导就行。</p>
<ol start="4">
<li><strong>缺失值的处理</strong></li>
</ol>
<p>对于特征的值有缺失的样本，XGBoost 可以自动学习出它的分裂方向。</p>
<ol start="5">
<li><strong>剪枝</strong></li>
</ol>
<p>XGBoost 先从顶到底建立所有可以建立的子树，再从底到顶反向进行剪枝。比起 GBM，这样不容易陷入局部最优解。</p>
<ol start="6">
<li><strong>内置交叉验证</strong></li>
</ol>
<p>XGBoost 允许在每一轮 Boosting 迭代中使用交叉验证。因此，可以方便地获得最优 Boosting 迭代次数。而 GBM 使用网格搜索，只能检测有限个值。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>虽然说 XGBoost 在 Kaggle 比赛中获得了不错的成绩，但并不代表 XGBoost 是一个完美的算法，它当然也有自己的缺点和不足之处:</p>
<ol>
<li><strong>算法参数过多</strong></li>
</ol>
<p>调参复杂，需要对 XGBoost 原理十分清楚才能很好的使用 XGBoost。</p>
<ol start="2">
<li><strong>只适合处理结构化数据</strong></li>
</ol>
<p>相对于深度学习算法来说，XGBoost 算法只适合处理结构化的特征数据，而对于类似图像中的目标检测等任务重的非结构化数据没有很好的处理能力。</p>
<ol start="3">
<li><strong>不适合处理超高维特征数据</strong></li>
</ol>
<p>XGBoost 算法对于中低维数据具有很好的处理速度和精度，但是对于例如大规模图像物体识别，或者是推荐算法的某些场景中会出现的超高维特征的数据就无能为力了，这时候我们就需要借助于深度学习等算法。</p>
<h2 id="八、-总结"><a href="#八、-总结" class="headerlink" title="八、 总结"></a>八、 总结</h2><h3 id="1-Boosting家族"><a href="#1-Boosting家族" class="headerlink" title="1. Boosting家族"></a>1. Boosting家族</h3><p>提升(Boosting)是集成学习方法里的一个重要方法，其主要思想是将弱分类器组装成一个强分类器。在 PAC（概率近似正确）学习框架下，则一定可以将弱分类器组装成一个强分类器。</p>
<p><strong>AdaBoost、GBDT、XGBoost</strong>都属于（加法模型、前向分步、指数损失函数）家族，都实现了通过将多个弱学习器组合成强学习器已达到提升预测准确度的目的。实现的过程略有不同且适用于不同场景。<br>Boosting并非是一个方法，而是一类方法。这里按照损失函数的不同，将其细分为若干类算法，下表给出了4种不同损失函数对应的Boosting方法：</p>
<p><img src="http://p6rvh6ej2.bkt.clouddn.com/15267180767470.jpg" alt=""></p>
<h3 id="2-Adaboost"><a href="#2-Adaboost" class="headerlink" title="2. Adaboost"></a>2. Adaboost</h3><p><strong>AdaBoost</strong>是一种典型的分类回归树，适合解决二分类问题。多分类问题解决起来比较麻烦（参考上文）</p>
<p><strong>AdaBoost</strong>是一种采用加法模型、前向分步算法、指数损失函数的提升树。可以表示为 Boosting 的前向分布算法的一个特例。 <a href="http://ihoge.cn/2018/adaboost.html" target="_blank" rel="noopener">更多内容请参考</a></p>
<h3 id="3-回归提升树和-Adaboost"><a href="#3-回归提升树和-Adaboost" class="headerlink" title="3. 回归提升树和 Adaboost"></a>3. 回归提升树和 Adaboost</h3><p><strong>回归提升树</strong>与<strong>AdaBoot</strong>不同的地方在于它使用的是平方损失函数来解决回归的问题，通过计算残差发现模型的不足，并不断拟合更新<strong>残差</strong>来构建新树。（这里残差的实现的功能与Adaboost有些类似）</p>
<h3 id="4-GBDT-和回归提升树"><a href="#4-GBDT-和回归提升树" class="headerlink" title="4. GBDT 和回归提升树"></a>4. GBDT 和回归提升树</h3><ol>
<li><strong>梯度提升树</strong>可以看作是特殊的一种回归提升树。它通过计算损失函数的负梯度在当前模型的值来近似回归树中的“残差”发现模型的不足，并通过拟合该“残差”构建新树。</li>
<li>回归提升树初始化另$f_0(x)=0$；GBDT初始化时令$f_{ 0 }(x)=arg\min _{ c } \sum _{ i=1 }^{ N }{ L(y_i,c) } $估计是损失函数极小化的常数值。</li>
<li>回归提升树通过平方损失函数计算残差，GBDT通过计算负梯度作为伪残差。</li>
</ol>
<h3 id="5-XGBoost-和-GBDT"><a href="#5-XGBoost-和-GBDT" class="headerlink" title="5. XGBoost 和 GBDT"></a>5. XGBoost 和 GBDT</h3><ul>
<li><p>Xgboost 是 GB 算法的高效实现，xgboost 中的基学习器除了可以是CART（gbtree）也可以是线性分类器（gblinear）</p>
</li>
<li><p>xgboost在目标函数中显示的加上了正则化项</p>
</li>
<li><p>GB 中使用 Loss Function 对 f(x) 的一阶导数计算出伪残差用于学习生成$f_m$，xgboost 不仅使用到了一阶导数，还使用二阶导数</p>
</li>
<li><p>CART 回归树中寻找最佳分割点的衡量标准是最小化均方差，xgboost 寻找分割点的标准是最大化，lamda，gama 与正则化项相关</p>
</li>
</ul>
<h3 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h3><p>[1] 《统计学习方法》  ——李航 2012 清华大学出版社<br>[2] 《机器学习》  ——周志华 2016 清华大学出版社<br>[3] <a href="http://ihoge.cn/2018/adaboost.html" target="_blank" rel="noopener">http://ihoge.cn/2018/adaboost.html</a><br>[4] <a href="https://www.jianshu.com/nb/7305482" target="_blank" rel="noopener">https://www.jianshu.com/nb/7305482</a><br>[5] <a href="http://www.52caml.com/head_first_ml/ml-chapter6-boosting-family/#Gradient_Boosting" target="_blank" rel="noopener">http://www.52caml.com/head_first_ml/ml-chapter6-boosting-family/#Gradient_Boosting</a><br>[6] <a href="https://www.jianshu.com/p/d55f7aaac4a7" target="_blank" rel="noopener">https://www.jianshu.com/p/d55f7aaac4a7</a><br>[7] <a href="http://gitbook.cn/gitchat/column/5ac2f0509e924a1dc029dd84/topic/5ac9e0e5dbd50e7493d35d3f" target="_blank" rel="noopener">http://gitbook.cn/gitchat/column/5ac2f0509e924a1dc029dd84/topic/5ac9e0e5dbd50e7493d35d3f</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/集合算法/" rel="tag"><i class="fa fa-tag"></i> 集合算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/XGBoost.html" rel="next" title="XGBoost算法学习总结">
                <i class="fa fa-chevron-left"></i> XGBoost算法学习总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/tensorflow1.html" rel="prev" title="深度学习——Tensorflow（1）">
                深度学习——Tensorflow（1） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTIxOC8xMTc1NA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘知行</p>
              <p class="site-description motion-element" itemprop="description">机器学习</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hooog" target="_blank" title="Github">
                      
                        <i class="fa fa-fw fa-globe"></i>Github</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hooog" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hooog" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、基本概念"><span class="nav-number">1.</span> <span class="nav-text">一、基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、前向分步加法模型（Forward-Stagewise-Additive-Modeling）"><span class="nav-number">2.</span> <span class="nav-text">二、前向分步加法模型（Forward Stagewise Additive Modeling）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-加法模型"><span class="nav-number">2.1.</span> <span class="nav-text">1. 加法模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-前向分步算法"><span class="nav-number">2.2.</span> <span class="nav-text">2. 前向分步算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、AdaBoost"><span class="nav-number">3.</span> <span class="nav-text">三、AdaBoost</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-AdaBoost算法解析"><span class="nav-number">3.1.</span> <span class="nav-text">1. AdaBoost算法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-AdaBoost构建步骤"><span class="nav-number">3.2.</span> <span class="nav-text">2. AdaBoost构建步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-AdaBoost算法缺点"><span class="nav-number">3.3.</span> <span class="nav-text">3. AdaBoost算法缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、二叉分类提升树（如AdaBoost）"><span class="nav-number">4.</span> <span class="nav-text">四、二叉分类提升树（如AdaBoost）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、二叉回归提升树"><span class="nav-number">5.</span> <span class="nav-text">五、二叉回归提升树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-回归问题提升树算法解析"><span class="nav-number">5.1.</span> <span class="nav-text">1. 回归问题提升树算法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-回归提升树构建步骤"><span class="nav-number">5.2.</span> <span class="nav-text">2. 回归提升树构建步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、梯度提升树（GBDT）"><span class="nav-number">6.</span> <span class="nav-text">六、梯度提升树（GBDT）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-梯度提升树-GBDT-算法解析"><span class="nav-number">6.1.</span> <span class="nav-text">1. 梯度提升树(GBDT)算法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-梯度回归树（GBDT）构建步骤"><span class="nav-number">6.2.</span> <span class="nav-text">2. 梯度回归树（GBDT）构建步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-GBDT缺点"><span class="nav-number">6.3.</span> <span class="nav-text">3. GBDT缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、XGBoost"><span class="nav-number">7.</span> <span class="nav-text">七、XGBoost</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XGBoost原理详解"><span class="nav-number">7.1.</span> <span class="nav-text">1. XGBoost原理详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-XGBoost的目标函数"><span class="nav-number">7.2.</span> <span class="nav-text">2. XGBoost的目标函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-XGBoost算法学习过程"><span class="nav-number">7.3.</span> <span class="nav-text">3. XGBoost算法学习过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-泰勒展开时近似损失函数"><span class="nav-number">7.4.</span> <span class="nav-text">4. 泰勒展开时近似损失函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-正则化的处理"><span class="nav-number">7.5.</span> <span class="nav-text">5. 正则化的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#决策树函数的定义"><span class="nav-number">7.5.1.</span> <span class="nav-text">决策树函数的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义决策树的复杂度"><span class="nav-number">7.5.2.</span> <span class="nav-text">定义决策树的复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新目标函数的优化"><span class="nav-number">7.5.3.</span> <span class="nav-text">新目标函数的优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-决策树构建"><span class="nav-number">7.6.</span> <span class="nav-text">6. 决策树构建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#决策树的生成策略"><span class="nav-number">7.6.1.</span> <span class="nav-text">决策树的生成策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找最优分裂点"><span class="nav-number">7.6.2.</span> <span class="nav-text">寻找最优分裂点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#离散变量处理"><span class="nav-number">7.6.3.</span> <span class="nav-text">离散变量处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#剪枝策略"><span class="nav-number">7.6.4.</span> <span class="nav-text">剪枝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前向分步的步长"><span class="nav-number">7.6.5.</span> <span class="nav-text">前向分步的步长</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-XGBoost构建步骤流程"><span class="nav-number">7.7.</span> <span class="nav-text">7. XGBoost构建步骤流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-XGBoost优缺点"><span class="nav-number">7.8.</span> <span class="nav-text">8. XGBoost优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">7.8.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">7.8.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、-总结"><span class="nav-number">8.</span> <span class="nav-text">八、 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Boosting家族"><span class="nav-number">8.1.</span> <span class="nav-text">1. Boosting家族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Adaboost"><span class="nav-number">8.2.</span> <span class="nav-text">2. Adaboost</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-回归提升树和-Adaboost"><span class="nav-number">8.3.</span> <span class="nav-text">3. 回归提升树和 Adaboost</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-GBDT-和回归提升树"><span class="nav-number">8.4.</span> <span class="nav-text">4. GBDT 和回归提升树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-XGBoost-和-GBDT"><span class="nav-number">8.5.</span> <span class="nav-text">5. XGBoost 和 GBDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-参考文献"><span class="nav-number">8.6.</span> <span class="nav-text">6. 参考文献</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘知行</span>

  
</div>


  <div class="powered-by">
  <span>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
  </div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
